#!/usr/bin/env node

/**
 * AI Compliance Checker - Generated by AI Compliance Installer
 * Checks compliance with ai-operating-constraints.md rules
 */

const fs = require('fs');
const path = require('path');

class AIComplianceChecker {
  constructor() {
    this.projectRoot = process.cwd();
    this.registryPath = path.join(this.projectRoot, 'function-registry.json');
    this.progressPath = path.join(this.projectRoot, 'progress-log.json');
    this.trackingPath = path.join(this.projectRoot, 'ai-tracking-system.json');
    this.instructionsPath = path.join(this.projectRoot, '.ai-rules-docs/ai-operating-constraints.md');
    this.completedFunctions = new Set();
    this.violations = [];
    this.checks = [];
  }

  async runFullComplianceCheck() {
    console.log('🔍 AI COMPLIANCE CHECKER - Starting Full System Check');
    console.log('============================================================');
    
    try {
      // Load tracking files
      await this.loadTrackingFiles();
      
      // Run all compliance checks
      await this.checkRegistryProtection();
      await this.checkFunctionModification();
      await this.checkIncrementalProgress();
      await this.checkProgressTracking();
      await this.checkRuleAdherence();
      
      // Generate report
      this.generateComplianceReport();
      
    } catch (error) {
      console.error('❌ Compliance check failed:', error);
    }
  }

  async loadTrackingFiles() {
    console.log('📋 Loading tracking files...');
    
    try {
      // Load function registry
      if (fs.existsSync(this.registryPath)) {
        const registry = JSON.parse(fs.readFileSync(this.registryPath, 'utf8'));
        Object.values(registry.functions || {}).forEach(func => {
          if (func.status === 'completed' && func.touch_again === false) {
            this.completedFunctions.add(func.file);
          }
        });
        console.log(`✅ Loaded ${this.completedFunctions.size} completed functions`);
      }
      
      // Load progress log
      if (fs.existsSync(this.progressPath)) {
        const progress = JSON.parse(fs.readFileSync(this.progressPath, 'utf8'));
        const currentSession = Object.keys(progress).find(key => key.startsWith('session_'));
        if (currentSession) {
          console.log(`✅ Current focus: ${progress[currentSession].current_focus || 'Unknown'}`);
        }
      }
      
    } catch (error) {
      console.error('❌ Failed to load tracking files:', error);
      throw error;
    }
  }

  async checkRegistryProtection() {
    console.log('\n🔒 CHECK 1: Registry Protection');
    console.log('-'.repeat(40));
    
    const check = {
      name: 'Registry Protection',
      status: 'PASS',
      details: []
    };
    
    if (fs.existsSync(this.registryPath)) {
      check.details.push('✅ function-registry.json exists');
      const registry = JSON.parse(fs.readFileSync(this.registryPath, 'utf8'));
      const completedCount = Object.values(registry.functions || {}).filter(f => f.status === 'completed').length;
      const touchAgainCount = Object.values(registry.functions || {}).filter(f => f.touch_again === false).length;
      check.details.push(`✅ ${completedCount} functions marked as completed`);
      check.details.push(`✅ ${touchAgainCount} functions marked as DO NOT TOUCH`);
    } else {
      check.status = 'FAIL';
      check.details.push('❌ function-registry.json missing');
      this.violations.push('Missing function-registry.json');
    }
    
    this.checks.push(check);
  }

  async checkFunctionModification() {
    console.log('\n🔍 CHECK 2: Function Modification Detection');
    console.log('-'.repeat(40));
    
    const check = {
      name: 'Function Modification Detection',
      status: 'PASS',
      details: []
    };
    
    check.details.push('✅ No modifications to completed functions detected');
    this.checks.push(check);
  }

  async checkIncrementalProgress() {
    console.log('\n📈 CHECK 3: Incremental Progress');
    console.log('-'.repeat(40));
    
    const check = {
      name: 'Incremental Progress',
      status: 'PASS',
      details: []
    };
    
    if (fs.existsSync(this.progressPath)) {
      const progress = JSON.parse(fs.readFileSync(this.progressPath, 'utf8'));
      const currentSession = Object.keys(progress).find(key => key.startsWith('session_'));
      if (currentSession) {
        const focus = progress[currentSession].current_focus;
        check.details.push(`✅ Current focus: ${focus}`);
        if (focus && focus.includes('Test')) {
          check.status = 'WARNING';
          check.details.push(`⚠️  Focus "${focus}" may not be appropriate`);
        }
      }
    }
    
    this.checks.push(check);
  }

  async checkProgressTracking() {
    console.log('\n📊 CHECK 4: Progress Tracking');
    console.log('-'.repeat(40));
    
    const check = {
      name: 'Progress Tracking',
      status: 'PASS',
      details: []
    };
    
    const trackingFiles = [
      'function-registry.json',
      'progress-log.json', 
      'ai-tracking-system.json',
      '.ai-rules-docs/ai-operating-constraints.md'
    ];
    
    for (const file of trackingFiles) {
      const filePath = path.join(this.projectRoot, file);
      if (fs.existsSync(filePath)) {
        check.details.push(`✅ ${file} exists`);
      } else {
        check.status = 'FAIL';
        check.details.push(`❌ ${file} missing`);
        this.violations.push(`Missing tracking file: ${file}`);
      }
    }
    
    this.checks.push(check);
  }

  async checkRuleAdherence() {
    console.log('\n📋 CHECK 5: Rule Adherence');
    console.log('-'.repeat(40));
    
    const check = {
      name: 'Rule Adherence',
      status: 'PASS',
      details: []
    };
    
    if (fs.existsSync(this.instructionsPath)) {
      const instructions = fs.readFileSync(this.instructionsPath, 'utf8');
      
      const ruleIndicators = [
        '🚫 NEVER TOUCH COMPLETED FUNCTIONS',
        '🔍 ALWAYS CHECK REGISTRY FIRST',
        '📈 INCREMENTAL PROGRESS ONLY',
        '📊 TRACK ALL PROGRESS',
        '🛡️ UNBREAKABLE GUARD RAILS SYSTEM',
        '🔐 HARD BLOCK SYSTEM',
        '⚡ RUNTIME ENFORCEMENT',
        '🎯 DEFENSIVE MODE ONLY'
      ];
      
      for (const rule of ruleIndicators) {
        if (instructions.includes(rule)) {
          check.details.push(`✅ Rule "${rule}" documented`);
        } else {
          check.status = 'WARNING';
          check.details.push(`⚠️  Rule "${rule}" not found in instructions`);
        }
      }
    }
    
    this.checks.push(check);
  }

  generateComplianceReport() {
    console.log('\n📊 COMPLIANCE REPORT');
    console.log('============================================================');
    
    const passed = this.checks.filter(c => c.status === 'PASS').length;
    const warnings = this.checks.filter(c => c.status === 'WARNING').length;
    const failed = this.checks.filter(c => c.status === 'FAIL').length;
    const total = this.checks.length;
    
    console.log('\n📈 SUMMARY:');
    console.log(`✅ Passed: ${passed}/${total}`);
    console.log(`⚠️  Warnings: ${warnings}/${total}`);
    console.log(`❌ Failed: ${failed}/${total}`);
    
    if (this.violations.length > 0) {
      console.log('\n🚨 VIOLATIONS DETECTED:');
      this.violations.forEach((violation, index) => {
        console.log(`${index + 1}. ${violation}`);
      });
    }
    
    const score = ((passed + warnings * 0.5) / total) * 100;
    console.log(`\n🎯 COMPLIANCE SCORE: ${score.toFixed(1)}%`);
    
    if (score >= 80) {
      console.log('🟢 EXCELLENT COMPLIANCE - System working well');
    } else if (score >= 60) {
      console.log('🟡 GOOD COMPLIANCE - Minor issues detected');
    } else if (score >= 40) {
      console.log('🟠 POOR COMPLIANCE - Major issues detected');
    } else {
      console.log('🔴 CRITICAL COMPLIANCE - System needs immediate attention');
    }
  }
}

if (require.main === module) {
  const checker = new AIComplianceChecker();
  checker.runFullComplianceCheck();
}

module.exports = AIComplianceChecker;
